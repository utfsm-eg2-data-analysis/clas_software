// Autogenerated Class (Source File)
// Author : G.Gavalian
// Date   : Fri Feb 29 16:56:45 EST 2008
//

#include "TFuncIntercept.h"



ClassImp(TFuncIntercept)


TFuncIntercept::TFuncIntercept (){

}

TFuncIntercept::~TFuncIntercept (){

}

//-----------------
//-----------------
//-----------------

 void   TFuncIntercept::InterCylinder(double vertex[],double cdir[],double center[], double d[], double r, double x[], int *ierr)
{
  double vp[3],va[3],vb[3];
  double a,b,c,k1,k2,k;
  double vp_dot_d,c_dot_d, delta;

  for(int i=0;i<3;i++){
    vp[i] = vertex[i] - center[i];
    x[i]  = 0.;
  }

  vp_dot_d = 0.;
  c_dot_d  = 0.;
  for(int i=0;i<3;i++){
    vp_dot_d += vp[i]*d[i];
    c_dot_d  += cdir[i]*d[i];
  }

  for(int i=0;i<3;i++){
    va[i] = cdir[i] - c_dot_d*d[i];
    vb[i] = vp[i] - vp_dot_d*d[i];
  }

  a = 0.;
  b = 0.;
  c = 0.;

  for(int i=0;i<3;i++){
    a = a + va[i]*va[i];
    b = b + 2.*va[i]*vb[i];
    c = c + vb[i]*vb[i];
  }
  c = c - r*r;

  delta = b*b - 4.*a*c;
  if(delta>0){
    k1 = (-b + sqrt(delta))/(2.*a);
    k2 = (-b - sqrt(delta))/(2.*a);
    if(k1>0){
      if(k2>0){
	k = k2;
	*ierr = 2;
      } else {
	k = k1;
	*ierr = 1;
      }
      for(int i=0;i<3;i++){
	x[i] = vertex[i] + k*cdir[i];
      }
    } else {
      *ierr = 0;
    }

  } else {
    *ierr = 0;
  }
}



void   TFuncIntercept::IntersectionPlane(double m1[], double m2[],double m0[],double n[],double m[],int *rep)
{
  int i;
  double kd,k;

  //  printf("momentum = %9.5f %9.5f %9.5f\n",n[0],n[1],n[2]);

  //  return;
  if(n[0]==0&&n[1]==0&&n[2]==0){
    *rep = -3;
    return;
  }
  
  *rep = 0;
  k   = 0.;
  for(int i=0;i<3;i++){
    k = k + (m1[i]-m0[i])*n[i];
  }
  //  return;
  if(fabs(k)<1e-10) *rep = -2;
  
  kd = 0;

  for(int i=0;i<3;i++){
    kd = kd + (m2[i]-m1[i])*n[i];
  }

  if(kd<1e-10){
    if((*rep)!=-1) *rep = 0;
    return;
  }

  k = 0.;
  for(int i=0;i<3;i++){
    k = k + (m0[i]-m1[i])*n[i];
  }

  k = k/kd;
  if(k>0&&k<1.){
    *rep = 1;
  } else {
    *rep = -1;
  }


  for(int i=0;i<3;i++){
    m[i] = m1[i] + k*(m2[i]-m1[i]);
  }
}
//===========================================
void   TFuncIntercept::IntersectionSphere(double m1[],double m2[],double m0[], double r, double m[], double mm[], int *rep)
{
  double a,b,c,k1,k2,kt,delta;
  int    i;
  a - 0.;
  for(i =0;i<3;i++){
    a += (m2[i]-m1[i])*(m2[i]-m1[i]);
  }
  if(fabs(a)<1e-10){
    *rep = 0;
    return;
  }
  b = 0.;
  for(i=0;i<3;i++){
    b += (m2[i] - m1[i])*(m1[i] - m0[i]);
  }

  c=0.;
  for(i =0;i<3;i++){
    c += (m1[i]-m0[i])*(m1[i]-m0[i]);
  }
  c = c - r*r;
  delta = b*b - a*c;
  if(delta<0) {
    *rep = 0;
    return;
  }
  k1 = (-b + sqrt(delta))/a;
  k2 = (-b - sqrt(delta))/a;
  *rep = -1;
  if(k1>0.&&k1<1.) *rep = 1;
  if(k2>0.&&k2<1.){
    if((*rep)==1){
      *rep = 2;
    } else {
      *rep = 1;
      kt = k1;
      k1 = k2;
      k2 = kt;
    }
  }

  if((*rep)==2||(*rep)==1){
    if(fabs(k1)>fabs(k2)){
      kt = k1;
      k1 = k2;
      k2 = kt;
    }
  }

  for(i=0;i<3;i++){
    m[i] = m1[i] + k1*(m2[i]-m1[i]);
    mm[i] = m1[i] + k2*(m2[i]-m1[i]);
  }
  
}


void  TFuncIntercept::IntersectionCylindre(double m1[],double  m2[],double  m0[], double d[], double r, double m[],double  mm[], int *rep)
{
  double mm1[4],mm2[4],mm0[4],dd[4];
  double a,b,c,k1,k2,kt,delta,norme;
  int i;
  norme = 0.;
  for(i=0;i<3;i++){
    norme += d[i]*d[i];
  }
  if(norme<1e-10){
    *rep = -3;
    return;
  }
  for(i=0;i<3;i++) d[i] = d[i]/norme;
  for(i=0;i<3;i++){
    mm1[i] = m1[i];
    mm2[i] = m2[i];
    mm0[i] = m0[i];
    dd[i]  = d[i];
  }

  mm1[3] = m1[0];
  mm2[3] = m2[0];
  mm0[3] = m0[0];
  dd[3]  = d[0];
  
  a = 0.;
  for(i=0;i<3;i++){
    a += (m2[i]-m1[i]) * (m2[i]-m1[i])*(1.-d[i]*d[i]);
    a += -2.*(m2[i]-m1[i])*(mm2[i+1]-mm1[i+1])*d[i]*dd[i+1];
  }

  if(fabs(a)<1e-10){
    *rep =0;
    return;
  }

  b = 0.;
  for(i=0;i<3;i++){
    b += (m2[i] - m1[i])*(m1[i]-m0[i])*(1.-d[i]*d[i]);
    b += -(m2[i]-m1[i])*(mm1[i+1]-mm0[i+1])*d[i]*dd[i+1];
    b += -(m1[i]-m0[i])*(mm2[i+1]-mm1[i+1])*d[i]*dd[i+1];
  }

  c = 0.;
  for(i=0;i<3;i++){
    c += (m1[i]-m0[i])*(m1[i]-m0[i])*(1.-d[i]*d[i]);
    c += -2.*(m1[i]-m0[i])*(mm1[i+1]-mm0[i+1])*d[i]*dd[i+1];
  }
  c = c - r*r;
  delta = b*b - a*c;
  if(delta<0.){
    *rep = 0;
    return;
  }

  k1 = (-b + sqrt(delta))/a;
  k2 = (-b - sqrt(delta))/a;

  *rep = -1;

  if(k1>0.&&k2<1.) *rep = 1;
  if(k2>0.&&k2<1.){
    if((*rep)==1){
      *rep = 2;
    } else {
      *rep = 1;
      kt = k1;
      k1 = k2;
      k2 = kt;
    }
  }
  
  for(i=0;i<3;i++){
    m[i]  = m1[i] + k1*(m2[i]-m1[i]);
    mm[i] = m1[i] + k2*(m2[i]-m1[i]);
  }
  
}

//=============================================================
void   TFuncIntercept::IntersectionCone(double m1[],double m2[],double m0[],double d[],double alpha, double m[],double mm[],int *rep)
{
  double a,b,c,k1,k2,kt,delta,norme,c2,a1,a2;
  int i;
  double  mm1[4],mm2[4],mm0[4],dd[4];

  c2 = cos(3.14159265359*(alpha/180.));
  c2 = c2*c2;
  norme = 0.;

  for(i=0;i<3;i++){
    norme += d[i]*d[i];
  }
  
  if(fabs(norme)<1e-10){
    *rep = -3;
    return;
  }
  for(i=0;i<3;i++){
    d[i] = d[i]/norme;
  }

  for(i =0 ; i <3 ; i++){
    mm1[i] = m1[i];
    mm2[i] = m2[i];
    mm0[i] = m0[i];
    dd[i]  = d[i];
  }
  mm1[3] = m1[0];
  mm2[3] = m2[0];
  mm0[3] = m0[0];
  dd[ 3] = d[ 0];

  a = 0.;
  for(i=0;i<3;i++){
    a+= (m2[i]-m1[i])*(m2[i]-m1[i])*(d[i]*d[i]-c2)
      + 2.*(m2[i]-m1[i])*(mm2[i+1]-mm1[i+1])*d[i]*dd[i+1];
  }

  if(fabs(a)<1e-10){
    *rep = 0;
    return;
  }
  
  b = 0.;
  for(i=0;i<3;i++)
    {
      b += (m2[i]-m1[i])*(m1[i]-m0[i])*(d[i]*d[i]-c2);
      b += (m2[i]-m1[i])*(mm1[i+1]-mm0[i+1])*d[i]*dd[i+1];
      b += (m1[i]-m0[i])*(mm2[i+1]-mm1[i+1])*d[i]*dd[i+1];
    }
  c = 0.;
  for(i=0;i<3;i++){
    c += (m1[i]-m0[i])*(m1[i] - m0[i])*(d[i]*d[i]-c2);
    c += 2.*(m1[i]-m0[i])*(mm1[i+1]-mm0[i+1])*d[i]*dd[i+1];
  }


  delta = b*b - a*c;
  if(delta<0){
    *rep = 0;
    return;
  }
  a1 = -b + sqrt(delta);
  a2 = -b - sqrt(delta);
  k1 = a1/a;
  k2 = a2/a;
  *rep = -1;
  if(k1>0.&&k1<1.) *rep = 1;
  if(k2>0.&&k2<1.){
    if((*rep)==1){
      (*rep) = 2;
    } else {
      (*rep) = 1;
      kt = k1;
      k1 = k2;
      k2 = kt;
      kt = a1;
      a1 = a2;
      a2 = kt;
    }
  }


  if((*rep)==2||(*rep)==-1){
    if(fabs(k1)>fabs(k2)){
      kt = k1;
      k1 = k2;
      k2 = kt;
      kt = a1;
      a1 = a2;
      a2 = kt;
    }
  }

  if(fabs(a1)<1e-4&&fabs(a)<1e-3) *rep = -2;
  for(i=0;i<3;i++)
    {
      m[i] = m1[i] + k1*(m2[i] - m1[i]);
      mm[i] = m1[i] + k2*(m2[i] - m1[i]);
    }
}

