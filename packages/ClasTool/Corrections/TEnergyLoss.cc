// Autogenerated Class (Source File)
// Author : G.Gavalian
// Date   : Fri Feb 29 19:46:04 EST 2008
//

#include "TEnergyLoss.h"


ClassImp(TEnergyLoss)


TEnergyLoss::TEnergyLoss (){
  fPAR_TargetOffset[0] = 0.;
  fPAR_TargetOffset[1] = 0.;
  fPAR_TargetOffset[2] = -1000.;
  fPAR_STOffset        = -1000.;
  fDebugMode           = 0;
  fEloss_Cell          = 0;
  fEloss_iFlag         = 0;

}

TEnergyLoss::~TEnergyLoss ()
{

}

//-----------------

void   TEnergyLoss::PrintWarning()
{
  printf("************************************************\n");
  printf("*  WARNING ! WARNING !                         *\n");
  printf("*  ELOSS Package is not Properly initialized   *\n");
  printf("************************************************\n");
  printf("\n");
  printf("Usage:\n\n");
  printf(" \t TEnergyLoss ClasLoss;\n");
  printf(" \t ClasLoss.Init(targcell);\n");
  printf("\n where targcell is : \n\n");
  printf(" 0 : no target\n");
  printf(" 1 : G1A/G1B/G6A/G6B\n");
  printf(" 2 : G2A\n");
  printf(" 3 : G1C\n");
  printf(" 4 : G3A\n");
  printf(" 5 : G6C/g8A\n");
  printf(" 6 : G10a\n");
  printf(" 7 : G11a\n");
  printf(" 8 : EG3a\n");
  printf("\n\n");
}

void   TEnergyLoss::Init(int icell, int iflag)
{

  fEloss_iFlag = iflag;
  fEloss_Cell  = icell;

  if(icell==0){

  }

  // This is G10a Setting
  // icell = 6

  if(icell==5){
    fPAR_TargetOffset[0] = 0.;
    fPAR_TargetOffset[1] = 0.;
    fPAR_TargetOffset[2] = -25.;
    fPAR_STOffset        = -20.0;
    fEloss_iFlag         = 2;
    printf("**************************************\n");
    printf("* Eloss Package initialized for G10  *\n");
    printf("*                                    *\n");
    printf("*  target offset = -25. cm           *\n");
    printf("*  st     offset = -20. cm           *\n");
    printf("*                                    *\n");
    printf("**************************************\n\n\n");

  }

  if(icell==6){
    fPAR_TargetOffset[0] = 0.;
    fPAR_TargetOffset[1] = 0.;
    fPAR_TargetOffset[2] = -10.;
    fPAR_STOffset        = -14.06;
    fEloss_iFlag         = 1;
    printf("**************************************\n");
    printf("* Eloss Package initialized for G11  *\n");
    printf("*                                    *\n");
    printf("*  target offset = -10.00 cm         *\n");
    printf("*  st     offset = -14.06 cm         *\n");
    printf("*                                    *\n");
    printf("**************************************\n\n\n"); 
  }

}

void   TEnergyLoss::Init(const char *runname)
{
  int  iflag = 0;
  if(strcmp(runname,"G11A")==0){
    Init(6,1);
    iflag = 1;
  }
  if(strcmp(runname,"G10A")==0){
    Init(5,2);
    iflag = 1;
  }

  if(iflag==0){
    printf("\n\n====>>>>\n");
    printf("\nERROR::ELOSS: Init: unrecognized Run period [%s]\n\n",runname);
  }
}

//-----------------
//-----------------
void   TEnergyLoss::LH2Targ(double vertex[],double cdir[],double *dist, double *dist1)
{
  double p_long,p_ryon,p_wall;
  double centre[3] = {0.,0.,0.};
  double dir[3]    = {0.,0.,1.};
  double pos1[3],pos2[3],pos1w[3],pos2w[3],point[3],r,x;
  int i,ierr,ierr1;

  int extrm;
  p_long  = 18.5;
  p_ryon = 3.;
  p_wall  = 0.017;

  for(i=0;i<3;i++) point[i] = vertex[i] + 10.*cdir[i];
  
  fInter.IntersectionCylindre(vertex,point,centre,dir,p_ryon,pos1,pos2,&ierr);
  double  kk = (vertex[0]-pos1[0])*(vertex[0]-pos2[0])+
    (vertex[1]-pos1[1])*(vertex[1]-pos2[1]);
  if(ierr==0||ierr==2||kk>0){
    *dist = 0;
    return;
  }


  extrm = 0;
  if(pos1[2]>(p_long/2.-p_ryon)) extrm = 1;
  if(-(p_long/2.-p_ryon)>pos1[2]) extrm = -1;

  if(extrm!=0){
    centre[2] = 1.*extrm*(p_long/2. - p_ryon);
    fInter.IntersectionSphere(vertex,point,centre,p_ryon,pos1,pos2,&ierr);
    if(ierr==0){
      *dist = 0;
      return;
    }
    r = p_ryon + p_wall;
    fInter.IntersectionSphere(vertex,point,centre,r,pos1w,pos2w,&ierr1);
    if(ierr==2){
      pos1[0]  = pos2[ 0];
      pos1[1]  = pos2[ 1];
      pos1[2]  = pos2[ 2];
      pos1w[0] = pos2w[0];
      pos1w[1] = pos2w[1];
      pos1w[2] = pos2w[2];
    }
  } else {
    r = p_ryon + p_wall;
    fInter.IntersectionCylindre(vertex,point,centre,dir,r,pos1w,pos2w,&ierr);
  }
  
  double dist_l = 0.;
  x = 0.;
  for(i=0;i<3;i++){
    dist_l = dist_l + (pos1[i] - vertex[i])*(pos1[i]-vertex[i]);
    x  = x + (pos1w[i] - vertex[i])*(pos1w[i]-vertex[i]);
  }
  
  *dist = sqrt(dist_l);
  x = sqrt(x);
  *dist1 = x - sqrt(dist_l);
}

//==================================
void   TEnergyLoss::CCylinder(double vertex[],double cdir[],double *dist)
{
  double centre[3];
  double p_ryon,thikness,extremtube,alpha,p_pi;
  double dir[3] = {0.,0.,1.};
  p_ryon = 9.4;
  thikness = 0.2;
  extremtube = 17.2;
  alpha = 30.;
  p_pi = 3.14159265359;
  int  ierr,ierr1,ierr2,i;
  double  point[3],pos1[3],pos2[3],intersec[3],intersec2[3],r;
  
  ierr1 = 0;
  ierr2 = 0;
  
  for(i=0;i<3;i++){
    point[i]  = vertex[i] + 50.*cdir[i];
    centre[i] = fPAR_TargetOffset[i];
  }
  fInter.InterCylinder(vertex,cdir,centre,dir,p_ryon,pos1,&ierr);
  if(ierr==0||ierr==2){
    *dist = 0.;
    return;
  }

  if(pos1[2]>(extremtube+centre[2])||ierr==-1){
    centre[2] = centre[2] + extremtube + p_ryon/tand(alpha);
    fInter.IntersectionCone(vertex,point,centre,dir,alpha,pos1,pos2,&ierr1);
    intersec[0] = pos1[0];
    intersec[1] = pos1[1];
    intersec[2] = pos1[2];
    centre[2]   = centre[2] + thikness/sind(alpha);
    fInter.IntersectionCone(vertex,point,centre,dir,alpha,pos1,pos2,&ierr2);
    
  } else {
    intersec[0] = pos1[0];
    intersec[1] = pos1[1];
    intersec[2] = pos1[2];
    r = p_ryon + thikness;
    fInter.InterCylinder(vertex,cdir,centre,dir,r,pos1,&ierr);
  }
  
  double dist_l = 0.;
  for(i=0;i<3;i++){
    dist_l += (pos1[i] - intersec[i])*(pos1[i] - intersec[i]);
  }

  *dist = sqrt(dist_l);

  if(cdir[2]>0){
    if(ierr1==-2||ierr2==-2){
      centre[2] = fPAR_TargetOffset[2] + extremtube + p_ryon/tand(alpha);
      point[ 2] = point[2] + 0.001;
      fInter.IntersectionCone(vertex,point,centre,dir,alpha,pos1,pos2,&ierr);
      intersec[0] = pos1[0];
      intersec[1] = pos1[1];
      intersec[2] = pos1[2];
      point[2] = point[2] - 0.002;
      fInter.IntersectionCone(vertex,point,centre,dir,alpha,pos1,pos2,&ierr);
      intersec[0] = (intersec[0]+pos1[0])/2.;
      intersec[1] = (intersec[1]+pos1[1])/2.;
      intersec[2] = (intersec[2]+pos1[2])/2.;
      centre[2] = centre[2] + thikness/sind(alpha);
      point[2]  = point[2] + 0.002;
      fInter.IntersectionCone(vertex,point,centre,dir,alpha,pos1,pos2,&ierr);
      intersec2[0] = pos1[0];
      intersec2[1] = pos1[1];
      intersec2[2] = pos1[2];

      point[2] = point[2] - 0.002;
      fInter.IntersectionCone(vertex,point,centre,dir,alpha,pos1,pos2,&ierr);
      intersec2[0] = (intersec2[0] - pos1[0])/2.;
      intersec2[1] = (intersec2[1] - pos1[1])/2.;
      intersec2[2] = (intersec2[2] - pos1[2])/2.;
      
      dist_l = 0;
      for(i=0;i<3;i++)
	dist_l += (intersec[i] - intersec2[i])*(intersec[i] - intersec2[i]);

      *dist = sqrt(dist_l);
    }
  }

}
//======================================================================
void   TEnergyLoss::TargetCell(int icell, double vertex[],double cdir[],double *dist, double *dist1)
{
  double dir[3]   = {0.,0.,1.};
  double alpha[3] = {1.7 , 0.87, 0.87};
  double RCON[3]  = {2.0 , 2.0, 2.0};
  double LR, LRC;
  int    ierr,ierr1,ierr2,i,extrm;
  double pos1[3],pos2[3],pos1w[3],pos2w[3],point[3],vc[3],cc[3];
  double r,r1,r2,h,x, dist_l;
  
  *dist  = 0.;
  *dist1 = 0.;

  if(icell<0||icell>8){
    printf("\n\nELOSS (C++): ERROR -> \n");
    printf("TARGETCELL: Unknown CELL (%d) \n",icell);
    printf("TARGETCELL: Use cell number (0-7)\n\n");
    return;
  }

  //===========================
  if(icell<5){
    for(i =0;i<3;i++){
      point[i] = vertex[i] + 1000.*cdir[i];
      cc[i] = fPAR_TargetOffset[i];
    }
    fInter.InterCylinder(vertex,cdir,cc,dir,TELossTargetCell::RC[icell],pos1,&ierr);
    if(ierr==0||ierr==2){
      *dist  = 0.;
      *dist1 = 0.;
      return;
    }
    extrm = 0;
    if(pos1[2]>(TELossTargetCell::LC[icell]+fPAR_TargetOffset[2])) extrm = 1;
    if((fPAR_TargetOffset[2] - TELossTargetCell::LC[icell])>pos1[2]) extrm = -1;
    
    if(extrm!=0){
      cc[2] = extrm*TELossTargetCell::LS[icell] + fPAR_TargetOffset[2];
      fInter.IntersectionSphere(vertex,point,cc,TELossTargetCell::RS[icell],
				pos1,pos2,&ierr);
      if(ierr==0){
	*dist  = 0.;
	*dist1 = 0.;
	return;
      }
      r = TELossTargetCell::RS[icell] + TELossTargetCell::WALL[icell];
      fInter.IntersectionSphere(vertex,point,cc,r,pos1w,pos2w,&ierr2);
      if(ierr==2){
	pos1[0] = pos2[0];
	pos1[1] = pos2[1];
	pos1[2] = pos2[2];
	pos1w[0] = pos2w[0];
	pos1w[1] = pos2w[1];
	pos1w[2] = pos2w[2];
      }
    } else {
      r = TELossTargetCell::RC[icell] + TELossTargetCell::WALL[icell];
      fInter.InterCylinder(vertex,cdir,cc,dir,r,pos1w,&ierr);
    }
    dist_l = 0.;
    x = 0.;
    for(i=0;i<3;i++){
      dist_l += (pos1[i] - vertex[i])*(pos1[i] - vertex[i]);
      x += (pos1w[i] - vertex[i])*(pos1w[i] - vertex[i]);
    }
    *dist = sqrt(dist_l);
    x = sqrt(x);
    *dist1 = x - sqrt(dist_l);
  }
  //============================
  if(icell>=5){
    for(i=0;i<3;i++){
      point[i] = vertex[i] + 1000.*cdir[i];
      cc[i]    = fPAR_TargetOffset[i];
    }
    if(fabs(vertex[2]-cc[2])<=(TELossTargetCell::LS[icell]+TELossTargetCell::RS[icell])){
      vc[0] = cc[0];
      vc[1] = cc[1];
      vc[2] = cc[2] + TELossTargetCell::LC[icell] + RCON[icell-5]/tand(alpha[icell-5]);
      LRC = (vc[2]-vertex[2])*tand(alpha[icell-5]);
      LR  = sqrt(vertex[0]*vertex[0]+vertex[1]*vertex[1]);
      if(LR<LRC){
	fInter.IntersectionCone(vertex,point,vc,dir,alpha[icell-5],pos1,pos2,&ierr);
	if(pos1[2]<(cc[2]+TELossTargetCell::LC[icell])){
	  vc[2] = vc[2] + TELossTargetCell::WALL[icell]/tand(alpha[icell-5]);
	  fInter.IntersectionCone(vertex,point,vc,dir,alpha[icell-5],pos1w,pos2w,&ierr);
	  dist_l = 0.;
	  x = 0.;
	  for(int i=0;i<3;i++){
	    dist_l += (pos1[i]-vertex[i])*(pos1[i]-vertex[i]);
	    x += (pos1w[i]-vertex[i])*(pos1w[i]-vertex[i]);
	  }
	  *dist  = sqrt(dist_l);
	  x = sqrt(x);
	  *dist1 = x - sqrt(dist_l);
	} else {
	  extrm = 1;
	  cc[2] = extrm*TELossTargetCell::LS[icell] + fPAR_TargetOffset[2];
	  fInter.IntersectionSphere(vertex,point,cc,
				    TELossTargetCell::RS[icell],pos1,pos2,&ierr);
	  if(ierr==0){
	    *dist  = 0.;
	    *dist1 = 0.;
	    return;
	  }
	  r = TELossTargetCell::RS[icell] + TELossTargetCell::WALL[icell];
	  fInter.IntersectionSphere(vertex,point,cc,r,pos1w,pos2w,&ierr1);
	  if(ierr==2){
	    pos1[0] = pos2[0];
	    pos1[1] = pos2[1];
	    pos1[2] = pos2[2];
	    pos1w[0] = pos2w[0];
	    pos1w[1] = pos2w[1];
	    pos1w[2] = pos2w[2];
	  }
	  dist_l = 0.;
	  x = 0.;
	  for(i=0;i<3;i++){
	    dist_l += (pos1[i]-vertex[i])*(pos1[i]-vertex[i]);
	    x = (pos1w[i] -vertex[i])*(pos1w[i] -vertex[i]);
	  }
	  *dist  = sqrt(dist_l);
	  x = sqrt(x);
	  *dist1 = x - sqrt(dist_l);

	  if((pos1w[0]*pos1w[0]+pos1w[1]*pos1w[1])<(0.5*0.5)&&
	     cdir[2]>0){
	    dist_l = *dist1;
	    //	    printf("\n\n\n====>>>\n\n");
	    *dist1 = dist_l/TELossTargetCell::WALL[icell]*
	      (TELossTargetCell::WALL[icell]+0.0015*2.70/1.032);
	  }
	}
      }
    }
  }
}

//=================================================================================
int    TEnergyLoss::DRound(double arg)
{
  return int(arg+0.5);
}
//=================================================================================
void   TEnergyLoss::AirGap(double vertex[],double cdir[],double xpoint[])
{
  double d_flat = 57.;
  double center_offset = -53.;
  double cyl_radius = 110.;
  double ncp[3] = {0.,0.,1.};
  
  int i, ierr,w;
  double alpha,phi,point[3],np[3],start[3];
  double theta,dir[3],autopoint[3];
  double norme,csinus,center[3],cpi[3];
  
  alpha = atan2(cdir[1],cdir[0]);
  alpha = 3.*alpha/S_PI;

  w = DRound( alpha);
  //  w = 1;
  //  printf("ROUNDING %f %d\n",alpha,w);
  phi = w*60.;
  
  np[0] = cosd(phi);
  np[1] = sind(phi);
  np[2] = 0.;

  for(i=0;i<3;i++){
    point[i] = vertex[i] + 1000.*cdir[i];
    start[i] = d_flat*np[i];
  }

  fInter.IntersectionPlane(vertex,point,start,np,autopoint,&ierr);

  if(autopoint[2]<=0.){
    for(i=0;i<3;i++)
      xpoint[i] = autopoint[i];
    return;
  } else {

    center[2] = 0.;
    center[0] = center_offset*np[0];
    center[1] = center_offset*np[1];
    dir[0] = np[1];
    dir[1] = - np[0];
    dir[2] = 0.;
    if(vertex[2]<0.){
      for(i=0;i<3;i++)
	start[i] = 0.;

      fInter.IntersectionPlane(vertex,point,start,ncp,autopoint,&ierr);
      fInter.InterCylinder(autopoint,cdir,center,dir,cyl_radius,xpoint,&ierr);
    } else {
      fInter.InterCylinder(vertex,cdir,center,dir,cyl_radius,xpoint,&ierr);
    }
  }
}


void   TEnergyLoss::StartCounter(int icell,double vertex[],double cdir[],double *dist, double xpoint[])
{
  double d_leg = 10.2;
  double thikness = 0.32;
  double half_length = 20.0;
  int  i, ierr,w;
  double alpha,phi,point[3],np[3],start[3],theta,dir[3],autopoint[3],norme,csinus;

  if(icell>=6){
    d_leg = 10.315;
    half_length = 26.15;
    thikness = 0.215 + 0.027*2*1.020/1.032 + 0.010*1.150/1.032 
      + 0.0013*1.300/1.032 + 0.975*0.031/1.032 + 0.571*0.110/1.032;
    alpha = atan2(cdir[1],cdir[0]);
    alpha = 3.*alpha/S_PI;
    w = DRound(alpha);
    phi = w*60.;
    
    np[0] = cosd(phi);
    np[1] = sind(phi);
    np[2] = 0.;
    
    for(i=0;i<3;i++){
      point[i] = vertex[i] + 500.*cdir[i];
      start[i] = d_leg*np[i];
    }

    fInter.IntersectionPlane(vertex,point,start,np,autopoint,&ierr);
    norme = 0.;
    for(i=0;i<3;i++){
      xpoint[i] = autopoint[i];
      norme += (autopoint[i]-vertex[i])*(autopoint[i]-vertex[i]);
    }
    norme = sqrt(norme);
    theta = 90.;
    if(autopoint[2]>(half_length+fPAR_STOffset)){
      theta = 60.;
      if(icell>=6) theta = 45.;
    }
    dir[0] = sind(theta)*cosd(phi);
    dir[1] = sind(theta)*sind(phi);
    dir[2] = cosd(theta);
    csinus = 0.;
    for(i=0;i<3;i++){
      csinus += (autopoint[i]-vertex[i])*dir[i];
    }
    csinus = csinus/norme;
    *dist = thikness/csinus;
    if(autopoint[2]>(half_length+fPAR_STOffset)){
      fInter.IntersectionPlane(vertex,point,start,dir,autopoint,&ierr);
      for(i=0;i<3;i++)
	xpoint[i] = autopoint[i];
    }
  }
}


void   TEnergyLoss::ScatteringChamber(int icell, double vertex[], double cdir[],double *dist,int *iwin,double pos1[])
{
  double dir[3] = {0.,0.,1.};
  double alpha, centre[3],rayon,rayon_win,thikness,thikness_win,extremtube[2];
  int  ierr,i;
  double point[3],pos2[3],intersec[3],r,angle;
  
  thikness     = 0.;
  thikness_win = 0.;
  rayon        = 0.;
  rayon_win    = 0.;
  extremtube[0]= 0.;
  extremtube[1]= 0.;
  alpha        = 0.;

  *iwin = 0;

  if(icell==6){
    thikness     = 0.978;
    thikness_win = 0.0071;
    rayon        = 4.235;
    rayon_win    = 2.000;
    extremtube[0]= 22.522;
    extremtube[1]=-24.724;
    alpha        = 0.;
  }
  if(icell==7){
    thikness     = 0.978;
    thikness_win = 0.0071;
    rayon        = 4.235;
    rayon_win    = 2.000;
    extremtube[0]= 22.522;
    extremtube[1]=-20.000;
    alpha        = 0.;
  }

  for(i=0;i<3;i++){
    point[i]  = vertex[i] + 500.*cdir[i];
    centre[i] = fPAR_TargetOffset[i];
  }

  if(vertex[2]>(extremtube[0]+centre[2])||
     vertex[2]<(extremtube[1]+centre[2])||
     (vertex[0]*vertex[0] + vertex[1]*vertex[1])>rayon*rayon){
    *dist = 0.;
    return;
  }
  
  fInter.InterCylinder(vertex,cdir,centre,dir,rayon,pos1,&ierr);



  if(ierr==0||ierr==2){
    *dist = 0.;
    return;
  }

  if(pos1[2]>(extremtube[0]+centre[2])||
     ierr==-1){
    centre[2] = centre[2] + extremtube[0];
    fInter.IntersectionPlane(vertex,point,centre,dir,pos1,&ierr);
    if(sqrt(pos1[0]*pos1[0]+pos1[1]*pos1[1])<rayon_win) *iwin=1;
    intersec[0] = pos1[0];
    intersec[1] = pos1[1];
    intersec[2] = pos1[2];
    centre[2] = centre[2] + thikness;
    fInter.IntersectionPlane(vertex,point,centre,dir,pos1,&ierr);
    if((*iwin)==1){
      intersec[0] = pos1[0];
      intersec[1] = pos1[1];
      intersec[2] = pos1[2];
      centre[2] = centre[2] + thikness_win;
      fInter.IntersectionPlane(vertex,point,centre,dir,pos1,&ierr);
    }
  } else {
    intersec[0] = pos1[0];
    intersec[1] = pos1[1];
    intersec[2] = pos1[2];
    r = rayon + thikness;
    fInter.InterCylinder(vertex,cdir,centre,dir,r,pos1,&ierr);
  }

  double dist_l = 0.;
  for(i=0;i<3;i++){
    dist_l += (pos1[i] - intersec[i])*(pos1[i] - intersec[i]);
  }
  *dist = sqrt(dist_l);
}

TVector3  TEnergyLoss::A2V(double pu[]){
  TVector3 av(pu[0],pu[1],pu[2]);
  return av;
}
void      TEnergyLoss::V2A(TVector3 v3,double pu[])
{
  pu[0] = v3.x();
  pu[1] = v3.y();
  pu[2] = v3.z();
}

TLorentzVector   TEnergyLoss::GetVector(TLorentzVector _vl, TVector3 v3_vrt)
{
  TVector3  v3_part = GetVector(_vl.Vect(),_vl.M(),v3_vrt,fEloss_iFlag,fEloss_Cell);
  TLorentzVector  vl_c;
  vl_c.SetVectM(v3_part,_vl.M());
  return vl_c;
}

TVector3   TEnergyLoss::GetVector(TVector3 v3_pout, double pmass, TVector3 v3_vrt, int iflag, int icell)
{

  TVector3  v3_out;
  int i,iwin,ierr,mate,loss;
  double p[3],po[3],pi[3],dist,dist1;
  double dens_foam,dens_scint,cdir[3],pmom;
  double gap,st_point[3],sc_point[3];
  double r1point[3],cell_point[3];
  double pout[3],vertex[3];


  if(fPAR_TargetOffset[3]<-900.||fPAR_STOffset<-900.){
    PrintWarning();
    return v3_out;
  }

  TVector3 v3out,v3in;

  pout[0] = v3_pout.x();
  pout[1] = v3_pout.y();
  pout[2] = v3_pout.z();

  vertex[0] = v3_vrt.x();
  vertex[1] = v3_vrt.y();
  vertex[2] = v3_vrt.z();

  pmom = v3_pout.Mag();

  for(i=0;i<3;i++){
    po[i] = pout[i];
    cdir[i] = pout[i]/pmom;
    pi[i] = po[i];
  }

  AirGap(vertex,cdir,r1point);
  
  StartCounter(icell,vertex,cdir,&dist,st_point);

  gap = sqrt((r1point[0]-st_point[0])*(r1point[0]-st_point[0]) +
	     (r1point[1]-st_point[1])*(r1point[1]-st_point[1]) +
	     (r1point[2]-st_point[2])*(r1point[2]-st_point[2])
	     );

  mate = 7;
  
  ierr = fLoss.Loss(mate,gap,pmass,po,p);

  if(fDebugMode>0){
    v3out = A2V(po);
    v3in  = A2V(p);
    printf("%18s : distance = %9.5f  P (b,a) = ( %9.5f , %9.5f) =>> %9.5f\n",
	   "Air Gap",gap,
	   v3out.Mag(),v3in.Mag(),100.*(v3in.Mag() - v3out.Mag())/v3out.Mag());
  }

  for(i=0;i<3;i++) pi[i] = p[i];

  mate = 1;

  ierr = fLoss.Loss(mate,dist,pmass,pi,p);
  if(fDebugMode>0){
    v3out = A2V(pi);
    v3in  = A2V(p);
    printf("%18s : distance = %9.5f  P (b,a) = ( %9.5f , %9.5f) =>> %9.5f\n",
	   "Start Counter",dist,
	   v3out.Mag(),v3in.Mag(),100.*(v3in.Mag() - v3out.Mag())/v3out.Mag());
  }
 

  for(i=0;i<3;i++) pi[i] = p[i];

  if(icell<6){
    CCylinder(vertex,cdir,&dist);
    if(dist!=0){
      mate = 2;
      ierr = fLoss.Loss(mate,dist,pmass,pi,p);
      if(fDebugMode>0){
	v3out = A2V(pi);
	v3in  = A2V(p);
	printf("%18s : distance = %9.5f  P (b,a) = ( %9.5f , %9.5f) =>> %9.5f\n",
	       "CCylinder ",dist,
	       v3out.Mag(),v3in.Mag(),100.*(v3in.Mag() - v3out.Mag())/v3out.Mag());
      }
      for(i=0;i<3;i++) pi[i] = p[i];
    }
  }


  if(icell>=6){

    ScatteringChamber(icell,vertex,cdir,&dist,&iwin,sc_point);

    if(dist!=0){
      gap = sqrt((st_point[0]-sc_point[0])*(st_point[0]-sc_point[0])
		 + (st_point[1]-sc_point[1])*(st_point[1]-sc_point[1])
		 + (st_point[2]-sc_point[2])*(st_point[2]-sc_point[2])
		 );
      mate = 7;
      ierr = fLoss.Loss(mate,gap,pmass,pi,p);
      if(fDebugMode>0){
	v3out = A2V(pi);
	v3in  = A2V(p);
	printf("%18s : distance = %9.5f  P (b,a) = ( %9.5f , %9.5f) =>> %9.5f\n",
	       "Scattering Chamb",gap,
	       v3out.Mag(),v3in.Mag(),100.*(v3in.Mag() - v3out.Mag())/v3out.Mag());
      }
 
      for(i=0;i<3;i++) pi[i] = p[i];
 
      if(iwin==0){
	mate = 1;
	dens_foam  = 0.110;
	dens_scint = 1.032;
	dist = dist *(dens_foam/dens_scint);
      } else {
	mate = 5;
      }

      ierr = fLoss.Loss(mate,dist,pmass,pi,p);
      if(fDebugMode>0){
	v3out = A2V(pi);
	v3in  = A2V(p);
	printf("%18s : distance = %9.5f  P (b,a) = ( %9.5f , %9.5f) =>> %9.5f\n",
	       "Scatt Chamber 2",dist,
	       v3out.Mag(),v3in.Mag(),100.*(v3in.Mag() - v3out.Mag())/v3out.Mag(),100.*(v3in.Mag() - v3out.Mag())/v3out.Mag());
      }
      for(i=0;i<3;i++) pi[i] = p[i];
    }
  }

  TargetCell(icell,vertex,cdir,&dist,&dist1);


  if(dist!=0){

    mate = 1;

    ierr = fLoss.Loss(mate,dist1,pmass,pi,p);
    if(fDebugMode>0){
      v3out = A2V(pi);
      v3in  = A2V(p);
      printf("%18s : distance = %9.5f  P (b,a) = ( %9.5f , %9.5f) =>> %9.5f\n",
	     "Target Wall ",dist1,
	     v3out.Mag(),v3in.Mag(),100.*(v3in.Mag() - v3out.Mag())/v3out.Mag());
    }
    for(i=0;i<3;i++) pi[i] = p[i];

    if(iflag!=0){
      mate = -1;
      if(iflag==1) mate = 0;
      if(iflag==2) mate = 3;
      if(iflag==3) mate = 4;
      if(iflag==4) mate = 6;
      ierr = fLoss.Loss(mate,dist,pmass,pi,p);
      if(fDebugMode>0){
	v3out = A2V(pi);
	v3in  = A2V(p);
	printf("%18s : distance = %9.5f  P (b,a) = ( %9.5f , %9.5f) =>> %9.5f\n","Target",
	       dist,v3out.Mag(),v3in.Mag(),100.*(v3in.Mag() - v3out.Mag())/v3out.Mag());
      }
      for(i=0;i<3;i++) pi[i] = p[i];

    }
  }

  if(fDebugMode>0){
    v3out = v3_pout;
    v3in  = A2V(pi);
    printf("%40s   P (b,a) = ( %9.5f , %9.5f) =>> %9.5f \%\n","Total Change \%",
	   v3out.Mag(),v3in.Mag(),100.*(v3in.Mag() - v3out.Mag())/v3out.Mag());
  }
  v3_out.SetXYZ(pi[0],pi[1],pi[2]);
  return v3_out;
}
