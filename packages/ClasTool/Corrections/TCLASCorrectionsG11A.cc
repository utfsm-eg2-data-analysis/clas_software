// Autogenerated Class (Source File)
// Author : G.Gavalian
// Date   : Sat Mar  1 14:14:02 EST 2008
//

#include "TCLASCorrectionsG11A.h"



ClassImp(TCLASCorrectionsG11A)


TCLASCorrectionsG11A::TCLASCorrectionsG11A (){

}

TCLASCorrectionsG11A::~TCLASCorrectionsG11A (){

}

//-----------------
//-----------------
//-----------------
void  TCLASCorrectionsG11A::Init(int mode )
{

}

TLorentzVector   TCLASCorrectionsG11A::GetVector(TLorentzVector  vPin, int charge, int type)
{
  TLorentzVector vPout;
  TVector3  v3_pcorr;
  TVector3  v3_pin = vPin.Vect();
  
  double    p_mom, lam, phi , p_mom_c, lam_c, phi_c;
  double    phi_lab = atan2(v3_pin.y(),v3_pin.x());
  double    p_mom_arr[3];
  
  int  bin = GetBin(v3_pin.Theta(),phi_lab);
  if(bin<0){
    vPout.SetVectM(v3_pin,vPin.M());
    return vPout;
  }

  p_mom_arr[0] = v3_pin.x();
  p_mom_arr[1] = v3_pin.y();
  p_mom_arr[2] = v3_pin.z();

  int sector = GetSector(p_mom_arr);

  p_mom = v3_pin.Mag();
  phi   = GetPhiTrack(p_mom_arr);
  lam   = GetLambdaTrack(p_mom_arr);

  //  printf("Sector Bin %d %d %f\n",sector,bin,phi_lab);
  
  double p_factor   = GetFunc_p(   p_mom,charge,bin,sector-1);
  double phi_factor = GetFunc_phi( p_mom,charge,bin,sector-1);
  double lam_factor = GetFunc_lam( p_mom,charge,bin,sector-1);

  double  p_scale = 1.;
  if(p_mom>2.) p_scale = 1.3;
  
  p_mom = p_mom + p_scale*p_factor;
  phi   = phi   + phi_factor;
  lam   = lam   + lam_factor;

  double  p_corr[3];

  SetP3FromTrackingParameters(p_mom,lam,phi,sector,p_corr);
  
  v3_pin.SetXYZ(p_corr[0],p_corr[1],p_corr[2]);
  vPout.SetVectM(v3_pin,vPin.M());
  return vPout;
}

TLorentzVector   TCLASCorrectionsG11A::GetTagger(TLorentzVector vG, int E_ID, int RunNum)
{
  double _e_beam;
  double _g_beam = vG.Pz();
  TLorentzVector  vResult;
  if(RunNum<44108){
      _e_beam =  4.01860;
  } else {
      _e_beam =  5.02114;
  }
  
  if(E_ID<=0||E_ID>767){
    printf("G11ACorrections:: Error in the E_ID number (%d)\n",E_ID);
    vResult.SetPxPyPzE(0.,0.,_g_beam,_g_beam);
    return vResult;
  }
  double dEg = _e_beam*TTAGGER_G11A::DATA_TaggerCorr[E_ID-1];
  if(RunNum>43490||RunNum<(43490+413)){
    dEg += TTAGGER_G11A::DATA_Beam_Offset[RunNum-43490];
  } else {
    printf("G11ATaggerCorrection:: Run number %d out of range [%d-%d]\n",
	   RunNum,43490,43490+413);
  }
  vResult.SetPxPyPzE(0.,0.,_g_beam + dEg, _g_beam + dEg);
  return vResult;
}

int       TCLASCorrectionsG11A::GetBin(double __theta,double __phi)
{
  double sec_phi = GetSectorPhi(__phi);
  sec_phi *= 180./3.14159;
  double theta = __theta * 180./3.14159;
  int phi_bin = -1;

 for(int i = 0; i < 12; i++){
   if(sec_phi >= TC_G11A_BIN::DATABIN_PHI_MIN[i] && 
      sec_phi < TC_G11A_BIN::DATABIN_PHI_MAX[i]){
      phi_bin = i;
      break;
    }
  }
  if(phi_bin == -1) return -1;

  int theta_bin = -1;
  for(int i = 0; i < 15; i++){
    if(theta >= TC_G11A_BIN::DATABIN_THETA_MIN[i] 
       && theta < TC_G11A_BIN::DATABIN_THETA_MAX[i]){
      theta_bin = i;
      break;
    }
  }
  if(theta_bin == -1) return -1;
  return 12*theta_bin + phi_bin;
  
}

double TCLASCorrectionsG11A::GetSectorPhi(double __phi){

  double sec_phi = __phi;
  int sign = 1;
  if(__phi < 0) sign = -1;
  if(fabs(sec_phi) < 3.14159/6.) return __phi;
  else{
    sec_phi -= sign*3.14159/3.;
    return GetSectorPhi(sec_phi);
  }


}
//_____________________________________________________________________________

void    TCLASCorrectionsG11A::SetP3FromTrackingParameters(double __p,double __lam,double __phi,
				 int __sector,double __p3[3]){

  double alpha = (3.14159/3.)*(__sector - 1);
  __p3[0] = __p*(cos(__lam)*sin(__phi)*cos(alpha) - sin(__lam)*sin(alpha));
  __p3[1] = __p*(cos(__lam)*sin(__phi)*sin(alpha) + sin(__lam)*cos(alpha));
  __p3[2] = __p*cos(__lam)*cos(__phi);    
}

double      TCLASCorrectionsG11A::GetFunc_p(double _p,int charge, int bin, int sector)
{
  double *p_ptr = NULL;
  if(charge<0&&sector==0) p_ptr = TC_G11A::DATACORR_P_NEG_S1;
  if(charge<0&&sector==1) p_ptr = TC_G11A::DATACORR_P_NEG_S2;
  if(charge<0&&sector==2) p_ptr = TC_G11A::DATACORR_P_NEG_S3;
  if(charge<0&&sector==3) p_ptr = TC_G11A::DATACORR_P_NEG_S4;
  if(charge<0&&sector==4) p_ptr = TC_G11A::DATACORR_P_NEG_S5;
  if(charge<0&&sector==5) p_ptr = TC_G11A::DATACORR_P_NEG_S6;
  if(charge>0&&sector==0) p_ptr = TC_G11A::DATACORR_P_POS_S1;
  if(charge>0&&sector==1) p_ptr = TC_G11A::DATACORR_P_POS_S2;
  if(charge>0&&sector==2) p_ptr = TC_G11A::DATACORR_P_POS_S3;
  if(charge>0&&sector==3) p_ptr = TC_G11A::DATACORR_P_POS_S4;
  if(charge>0&&sector==4) p_ptr = TC_G11A::DATACORR_P_POS_S5;
  if(charge>0&&sector==5) p_ptr = TC_G11A::DATACORR_P_POS_S6;

  if(p_ptr == NULL) return 0.;

  int     start_p = bin*3;
  double  pars[3],p_factor = 0.;
  for(int i=0;i<3;i++) pars[i] = p_ptr[start_p+i];
  if(fabs(pars[2])<1e-10){
    p_factor = pars[0]*_p + pars[1];
  } else {
    p_factor = pars[0]*_p*_p + pars[1]*_p+pars[2];
  }
  return p_factor;
}

double      TCLASCorrectionsG11A::GetFunc_phi(double _p,int charge, int bin, int sector)
{
 double *p_ptr = NULL;
  if(charge<0&&sector==0) p_ptr = TC_G11A::DATACORR_PHI_NEG_S1;
  if(charge<0&&sector==1) p_ptr = TC_G11A::DATACORR_PHI_NEG_S2;
  if(charge<0&&sector==2) p_ptr = TC_G11A::DATACORR_PHI_NEG_S3;
  if(charge<0&&sector==3) p_ptr = TC_G11A::DATACORR_PHI_NEG_S4;
  if(charge<0&&sector==4) p_ptr = TC_G11A::DATACORR_PHI_NEG_S5;
  if(charge<0&&sector==5) p_ptr = TC_G11A::DATACORR_PHI_NEG_S6;
  if(charge>0&&sector==0) p_ptr = TC_G11A::DATACORR_PHI_POS_S1;
  if(charge>0&&sector==1) p_ptr = TC_G11A::DATACORR_PHI_POS_S2;
  if(charge>0&&sector==2) p_ptr = TC_G11A::DATACORR_PHI_POS_S3;
  if(charge>0&&sector==3) p_ptr = TC_G11A::DATACORR_PHI_POS_S4;
  if(charge>0&&sector==4) p_ptr = TC_G11A::DATACORR_PHI_POS_S5;
  if(charge>0&&sector==5) p_ptr = TC_G11A::DATACORR_PHI_POS_S6;

  if(p_ptr == NULL) return 0.;

  double phi_factor = 0.;
  double pars[4];
  int start = bin*4;
  for(int i=0;i<4;i++) pars[i] = p_ptr[start+i];

  if(fabs(pars[2])<1e-10&&fabs(pars[3])<1e-10){
    phi_factor = pars[0]*_p + pars[1];
  } else {
    phi_factor = pars[0]/(_p*_p*_p) + pars[1]/(_p*_p) + pars[2]/_p+pars[3];
  }
  return phi_factor;
}

double      TCLASCorrectionsG11A::GetFunc_lam(double _p,int charge, int bin, int sector)
{
 double *p_ptr = NULL;
  if(charge<0&&sector==0) p_ptr = TC_G11A::DATACORR_LAM_NEG_S1;
  if(charge<0&&sector==1) p_ptr = TC_G11A::DATACORR_LAM_NEG_S2;
  if(charge<0&&sector==2) p_ptr = TC_G11A::DATACORR_LAM_NEG_S3;
  if(charge<0&&sector==3) p_ptr = TC_G11A::DATACORR_LAM_NEG_S4;
  if(charge<0&&sector==4) p_ptr = TC_G11A::DATACORR_LAM_NEG_S5;
  if(charge<0&&sector==5) p_ptr = TC_G11A::DATACORR_LAM_NEG_S6;
  if(charge>0&&sector==0) p_ptr = TC_G11A::DATACORR_LAM_POS_S1;
  if(charge>0&&sector==1) p_ptr = TC_G11A::DATACORR_LAM_POS_S2;
  if(charge>0&&sector==2) p_ptr = TC_G11A::DATACORR_LAM_POS_S3;
  if(charge>0&&sector==3) p_ptr = TC_G11A::DATACORR_LAM_POS_S4;
  if(charge>0&&sector==4) p_ptr = TC_G11A::DATACORR_LAM_POS_S5;
  if(charge>0&&sector==5) p_ptr = TC_G11A::DATACORR_LAM_POS_S6;

  if(p_ptr == NULL) return 0.;
  if(p_ptr == NULL) return 0.;

  double lam_factor = 0.;
  double pars[4];
  int start = bin*4;
  for(int i=0;i<4;i++) pars[i] = p_ptr[start+i];

  if(fabs(pars[2])<1e-10&&fabs(pars[3])<1e-10){
    lam_factor = pars[0]*_p + pars[1];
  } else {
    lam_factor = pars[0]/(_p*_p*_p) + pars[1]/(_p*_p) + pars[2]/_p+pars[3];
  }

  return lam_factor;
  
}

double TCLASCorrectionsG11A::GetLambdaTrack( double __p3[3]){

  double lambda;
  double px = __p3[0],py = __p3[1],pz = __p3[2];
  double p_mag = sqrt(px*px + py*py + pz*pz);
  double x = px/p_mag,y = py/p_mag;
  
  double alpha = (3.14159/3.)*(GetSector(__p3)-1);
  lambda = asin(cos(alpha)*y - sin(alpha)*x);
  return lambda;

}
//_____________________________________________________________________________
/// Calculates the tracking angle \f$ \phi \f$.
double TCLASCorrectionsG11A::GetPhiTrack(double __p3[3]){

  double phi;
  double px = __p3[0],py = __p3[1],pz = __p3[2];
  double z = pz/sqrt(px*px + py*py + pz*pz); // normalized z_lab
  double lambda = GetLambdaTrack(__p3);

  phi = acos(z/cos(lambda));
  return phi;
}
int   TCLASCorrectionsG11A::GetSector( double __p3[3]){

  int sector = 0;
  double px = __p3[0],py = __p3[1],pz = __p3[2];
  double pi = 3.14159;
  double phi_lab = atan2(py,px);
  double phi = (180./pi)*phi_lab; // radians --> degrees

  if(std::abs(phi) <= 30.) sector = 1;
  else if(phi > 0.){
    if(phi <= 90.) sector = 2;
    else if(phi <= 150) sector = 3;
    else sector = 4;
  }
  else {
    // phi < 0
    if(std::abs(phi) <= 90.) sector = 6;
    else if(std::abs(phi) <= 150.) sector = 5;
    else sector = 4;
  }
  return sector;
}
